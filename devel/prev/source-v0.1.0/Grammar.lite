LiteScript Grammar
==================

The LiteScript Grammar is based on [Parsing Expression Grammars (PEGs)](http://en.wikipedia.org/wiki/Parsing_expression_grammar)
with some extensions.

The LiteScript Grammar is defined as `classes`, one class for each non-terminal symbol.

The `.parse()` method of each class will try the grammar on the token stream and:
* If all tokens match, it will simply return after consuming the tokens.
* On a token mismatch, it will raise a 'parse failed' exception.

When a 'parse failed' exception is raised, other classes can be tried. If none parses ok, a compiler error
is emitted and compilation is aborted.

if the error is produced *before* the class has determined this was the right language construction,
it is a soft-error and other grammars can be tried over the source code.

if the error is produced *after* the class has determined this was the right language construction 
(if the node is 'locked'), it is a hard-error and a compiler error is raised

The `ASTBase` module defines the base class for the grammar classes along with
utility methods to **req**uire tokens and allow **opt**ional ones.

    var ASTBase = require('./ASTBase')
    var Lexer = require('./Lexer')

/!

    compiler set sourceMap = false

    declare debug,log,process

    declare valid log.error
    declare valid log.warning
    declare valid process.exit


    declare on ASTBase 
      ownMember,addMember
      getRootNode,globalVar
      createScope,createFunctionScope,addToScope,addVarsToScope,findInScope
      parseParametersAndBody

    # forward declares

    declare 
      StatementsDirect, AccessorsDirect, FunctionAccess

    declare 
      Module, Expression, FreeObjectLiteral, NameValuePair
      SingleLineStatement, Body, ExceptionBlock
      ElseIfStatement, ElseStatement, ForEachProperty
      Accessors, 
      ForIndexNumeric, ForEachInArray
      VariableRef, FunctionDeclaration
      ParenExpression,ArrayLiteral,ObjectLiteral
      StringLiteral, NumberLiteral, RegExpLiteral
      ClassDeclaration,AppendToDeclaration,Adjective

!/

Reserved Words
----------------------

Words that are reserved in LiteScript and cannot be used as variable or function names
(There are no restrictions to object property names)

    var RESERVED_WORDS = ['function'
        ,'class','method','constructor','prototype'
        ,'if','then','else'
        ,'null','true','false','undefined'
        ,'and','or','but','no','not','bitwise','has','property','properties'
        ,'mod','new','is','isnt'
        ,'do','loop','while','until','for','to','break','continue'
        ,'return','try','catch','throw','raise','fail','exception','finally'
        ,'with','arguments','in','instanceof','typeof'
        ,'var','let','default','delete','interface','implements','yield'
        ,'me','this','super'
        ,'public','compiler','compile','debugger']


Operators precedence
--------------------

The order of symbols in `operatorsPrecedence`,  determines operators precedence

    var operatorsPrecedence = [ '++','--', 'unary -', 'unary +', 'bitwise not'
      ,'bitwise and', 'bitwise xor' ,'bitwise or'
      ,'>>','<<'
      ,'new','type of','instance of','has property','no'
      ,'^','*','/','mod','+','-'
      ,'in'
      ,'>','<','>=','<=','is','<>'
      ,'not','and','but','or'
      ,'?',':' ]

--------------------------------------

Grammar Meta-Syntax
===================

Each Grammar class parsing code, contains a 'grammar definition' as reference. 
The meta-syntax for the grammar definitions is 
an extended form of [Parsing Expression Grammars (PEGs)](http://en.wikipedia.org/wiki/Parsing_expression_grammar)

The differences with classic PEG are:
* instead of **Symbol <- definition**, we use **Symbol: definition**
* we use **[Symbol]** for optional symbols instead of **Symbol?** (brackets also groups symbols, the entire group is optional)
* symbols upper/lower case carries meaning
* we add **,|; Separated List** as a syntax option

Examples:

`IfStatement`    : CamelCase is reserved for non-terminal symbol 
`function`       : all-lowercase means the literal word
`":"`            : literal symbols are quoted

`IDENTIFIER`,`OPER` : all-uppercase denotes entire classes of symbols 
`NEWLINE`,`EOF`     : or special unprintable characters

`[of]`               : Optional symbols are enclosed in brackets
`(var|let)`          : The vertical bar represents ordered alternatives
`(Oper Operand)`     : Parentheses groups symbols
`(Oper Operand)*`    : Asterisk after a group `()*` means the group can repeat (one or more)
`[Oper Operand]*`    : Asterisk after a optional group `[]*` means zero or more of the group

`"(" [Expression,] ")"` : the comma means a comma "Separated List". When a "Separated List" is accepted,
                         also a *free-form* is accepted

`Body: (Statement;)` : the semicolon means: a semicolon "Separated List". When a "Separated List" is accepted,
                         also a *free-form* is accepted

"Separated List"
----------------

Example: `FunctionCall: IDENTIFIER "(" [Expression,] ")"`

`[Expression,]` means *optional* **comma "Separated List"** of Expressions. When the comma is 
inside a **[]** group, it means the entire list is optional.

Example: `VarStatement: (VariableDecl,)`

`(VariableDecl,)` means **comma "Separated List"** of `VariableDecl` (`VariableDecl: IDENTIFIER ["=" Expresion]`). 
When the comma is inside a **()** group, it means one or more of the group

At every point where a "Separated List" is accepted, also 
a "**free-form** Separated List" is accepted.

In *free-form* mode, each item stands on its own line, and separators (comma/semicolon) 
are optional, and can appear after or before the NEWLINE.

For example, given the previous example: `VarStatement: var (VariableDecl,)`, 
all of the following constructions are equivalent and valid in LiteScript:

Examples: 
/*

    //standard js

    var a = {prop1:30 prop2: { prop2_1:19, prop2_2:71} arr:["Jan","Feb","Mar"]}


    //mixed freeForm and comma separated

    var a =
        prop1: 30

        prop2: 
          prop2_1: 19
          prop2_2: 71

        arr: [ "Jan", 
              "Feb", "Mar"]


    //in freeForm, commas are optional

    var a = {
        prop1: 30
        prop2: 
          prop2_1: 19,
          prop2_2: 71,
        arr: [ 
            "Jan", 
            "Feb"
            "Mar" 
            ]
        }
*/


--------------------------

LiteScript Grammar - AST Classes
================================


PrintStatement
--------------

`PrintStatement: 'print' [Expression,]`

This handles `print` followed by am optional comma separated list of expressions

    class PrintStatement inherits from ASTBase

/!  
    
      properties
        args
!/

      method parse()

        me.reqValue 'print'

At this point we lock because it is definitely a `print` statement. Failure to parse the expression 
from this point is a syntax error.

        me.lock()

        me.args = me.optSeparatedList(Expression,",")


Require Name Declaration
------------------------

We want to avoid time lost debugging a mistyped object property, or variable, or function name.

All identifiers (names) used in LiteScript must be previously declared.
Names are case-controled, you  must use them always with the same case. 
It means you can not have `totals` and `toTals` as different vars on the same scope.


Commonly used identifier aliases
--------------------------------

This are a few aliases to most used built-in identifiers:

    var IDENTIFIER_ALIASES =
      'on':         'true'
      'off':        'false'
      'me':         'this'


NameDeclaration
---------------

`NameDeclaration` is a helper class used to parse an identifier.
It does 'alias' conversion and also store:
* 'members', a map of names declared under this name 
For example, dependent name:value in object expressions, methods in a class, etc.
* type
* itemType (whe type is Array)

    class NameDeclaration inherits from ASTBase

It's used for `var` names, `class` names, `function` name and parameter names, etc.

/!  
    
      properties
        name, members, isForward, value
        type,itemType
!/

      method initialize()
          me.members={} #start with empty .members map
          return ASTBase.prototype.constructor.apply(this,arguments)

      method parse()

Require an `IDENTIFIER` token
/!

        declare ident:string
!/        

        var ident = me.req('IDENTIFIER')

translate common aliases: me --> this,  on --> true / off --> false

        me.name = ident.translate(IDENTIFIER_ALIASES)

      #end parse

###NameDeclaration Helper methods

debug helper method *toString*

      method toString() 
        var result = me.name
        var node = me.parent
        while node instanceof NameDeclaration and not node.isScope
          #prepend owner name until we reach a scope
          result = node.name +'.'+ result
          node = node.parent
        #loop
        return result

debug helper method *originalDeclarationText*

      method originalDeclarationText() 
        return "#{me.positionText()} for reference: original declaration of '#{me.name}'"


###a Helper function, *.declareName*
.declareName creates a new NameDeclaration.

    method declareName(name, options) of ASTBase

/!

        declare on options
          type,isForward,value
      

!/

        var newDecl = new NameDeclaration(me)
        newDecl.name = name
        if options 
          if options.type 
              newDecl.type = options.type
          if options.isForward 
              newDecl.isForward = options.isForward
          if options.hasOwnProperty('value')
              newDecl.value = options.value

        return newDecl


###a Helper Function **addToExport**
Add to parentModule.exports

    method addToExport(param) of ASTBase
      
      var parentModule = me.getParent(Module)

      if param instanceof NameDeclaration
          parentModule.exports.addMember(param,{keepParent:true})
      else
          parentModule.exports.addMembers(param,{keepParent:true})
          

Note: All other methods added to NameDeclaration are in the 'Scope' module

-----


## VariableDecl

`VariableDecl: NameDeclaration (':' dataType-IDENTIFIER) ('=' defaultValue-Expression)`

variable name, optional type anotation and optionally assign a value

Note: If no value is assigned, `= undefined` is assumed

VariableDecls are used in `var` statement, in functions for *parameter declaration*
and in class *properties declaration*

Example:  
  `var a : string = 'some text'` 
  `function x ( a : string = 'some text', b, c=0)`

    class VariableDecl inherits from ASTBase
/!  
    
      properties
        name:NameDeclaration  
        referencedName:NameDeclaration
        assignedValue

!/

      method parse()

        me.name = me.req(NameDeclaration)
        me.referencedName = me.name #to compatibilize with VariableRef

        me.lock()

optional type annotation.

        if me.optValue(':')  

          #auto-capitalize core classes
          if me.lexer.token.value in ['string','array','number','object','function','boolean']
            me.lexer.token.value = me.lexer.token.value[0].toUpperCase()+me.lexer.token.value.slice(1)
/!

          declare typeRef
          declare valid typeRef.referencedName.members.prototype
          declare valid typeRef.referencedName.name
          declare valid this.globalVar
          declare valid this.name.name.slice
          declare valid this.findInScope
          declare valid this.name.type
          declare valid this.name.itemType
          declare valid this.scopeEvaluateAssignment

          declare possibleClass:NameDeclaration
          declare valid possibleClass.members.prototype
!/

          var typeRef = me.req(VariableRef)

          me.name.type = typeRef.referencedName
          if typeRef.referencedName.members.prototype # a class
            me.name.type = typeRef.referencedName.members.prototype

          var isArray =  me.ifOptValue('Array','array')
          if isArray
              me.name.itemType = me.name.type #assign as sub-type
              me.name.type = me.globalVar('Array').members.prototype


if there is no type specified, but the name is lowercase of a Class name, we assume type is class.prototype

        else

          var capitalized = me.name.name[0].toUpperCase() + me.name.name.slice(1)
          if capitalized isnt me.name.name 
            var possibleClass = me.findInScope(capitalized)
            if possibleClass
              me.name.type = possibleClass.type
              if possibleClass.members.prototype
                me.name.type = possibleClass.members.prototype

optional assigned value

        if me.optValue('=')
          if me.lexer.token.type is 'NEWLINE' #dangling assignment, assume free-form object literal
            me.assignedValue   = me.req(FreeObjectLiteral)
          else
            me.assignedValue   = me.req(Expression)

Now evaluate assignment to:
a. Recognize `exports.name = x` as alternative to declaring x `public`
b. Recognize `name = require('name')` as alternative to `import name` 
c. auto assign type

          me.scopeEvaluateAssignment(me, me.name, me.assignedValue)


## Var Statement

`VarStatement: (var|let) (VariableDecl,) `

`var` followed by a comma separated list of VariableDecl (one or more items)

    class VarStatement inherits from ASTBase

/!

      properties list:array
!/

      method parse()

        me.reqValue('var','let')
        me.lock()

        me.list = me.reqSeparatedList(VariableDecl,",")

Scope: Now add all the declared variables to the parent scope        
and if 'public' add to exported names

/!

        declare valid this.addVarsToScope
        declare valid this.parent.isAdjectivated
!/

        me.addVarsToScope me.list

        if me.parent.isAdjectivated('public')
          me.addToExport me.list


## PropertiesDeclaration

`PropertiesDeclaration: properties (VariableDecl,)`

The `properties` keyword is used inside classes to define properties of the class (prototype).
*PropertiesDeclaration* derives from *VarStatement* in order to use the same '.produce()' method.

    class PropertiesDeclaration inherits from VarStatement

      method parse()

        me.singleton = me.optValue('namespace')
        me.reqValue 'properties'
        me.lock()

        var parentClass = me.getParent(ClassDeclaration) #gets parent class/append to
        if no parentClass
          me.throwError "'properties' declaration outside class/append declaration. Check indent"

        var ownerObj
        if me.singleton
          ownerObj = parentClass.name
        else if parentClass instanceof AppendToDeclaration
          # 'properties' inside a "append to" -> assign to exact object
          ownerObj = parentClass.referenced
        else
          # 'properties' inside a class -> assign to prototype
          ownerObj = parentClass.name.members.prototype

        me.list = me.reqSeparatedList(VariableDecl,',')

Now add all properties as valid class.prototype members
and make names childs of ownerObj

        for varDecl in me.list
          ownerObj.addMember varDecl.name
          varDecl.name.parent = ownerObj
          

##TryCatch


`TryCatch: 'try' Body ExceptionBlock`

Defines a `try` block for trapping exceptions and handling them. 

    class TryCatch inherits from ASTBase
/!

      properties body,exceptionBlock
!/

      method parse()
        me.reqValue 'try'
        me.lock()
        me.body = me.req(Body)

        me.exceptionBlock = me.req(ExceptionBlock)


## ExceptionBlock


`ExceptionBlock: (exception|catch) NameDeclaration Body [finally Body]`

Defines a `catch` block for trapping exceptions and handling them. 
If no `try` preceded this construction, `try` is assumed at the beggining of the function

    class ExceptionBlock inherits from ASTBase
/!

      properties 
        catchVar:NameDeclaration
        body,finallyBody
!/

      method parse()
/!

        declare valid this.createScope
        declare valid this.addToScope
!/

        me.reqValue 'exception','catch'
        me.lock()

get catch variable - Note: catch variables in js are block-scoped

        me.catchVar = me.req(NameDeclaration)
        if not me.catchVar.type
          me.catchVar.type = me.globalVar('Error').members.prototype

add catched err var to exception-block scope
        
        me.createScope()
        me.addToScope me.catchVar

get body 

        me.body = me.req(Body)

get optional "finally" block

        if me.optValue('finally')
          me.finallyBody = me.req(Body)

If no `try` preceded this construction, we assume this is the function exception handler,
so we mark the function `hasExceptionBlock` (producer_js: will add 'try{' at function start)

        if not (me.parent instanceof TryCatch)

            var functionScope = me.getParent(FunctionDeclaration)

            if no functionScope
              me.throwError '[ExceptionBlock] found outside a function'

            if functionScope.exceptionBlock
              me.throwError "Two [ExceptionBlocks] found for the same function: #{functionScope.name}"

            functionScope.exceptionBlock = me


## ThrowStatement

`ThrowStatement: (throw|raise|fail with) Expression`

This handles `throw` and its synonyms followed by an expression 

    class ThrowStatement inherits from ASTBase
/!
      
      properties specifier, expr
!/

      method parse()
        me.specifier = me.reqValue('throw', 'raise', 'fail')

At this point we lock because it is definitely a `throw` statement

        me.lock()

        if me.specifier is 'fail'
            me.reqValue 'with'

        me.expr = me.req(Expression)


## ReturnStatement


`ReturnStatement: return Expression`

    class ReturnStatement inherits from ASTBase
/!
      
      properties expr
!/

      method parse()
        me.reqValue 'return'
        me.lock() #Definitely a return statement at this point.
        me.expr = me.opt(Expression)


IfStatement
-----------

`IfStatement: (if|when) Expression (then|',') SingleLineStatement [ElseIfStatement|ElseStatement]*`
`IfStatement: (if|when) Expression Body [ElseIfStatement|ElseStatement]*`
 
Parses `if` statments and any attached `else`s or `else if`s 

    class IfStatement inherits from ASTBase
/!
      
      properties conditional,body,elseStatement
!/

      method parse()

        me.reqValue 'if','when'
        me.lock()

        me.conditional = me.req(Expression)

        if me.optValue(',','then')

after `,` or `then`, a statement on the same line is required 

            me.body = me.req(SingleLineStatement)
        
        else # and indented block
            if me.lexer.token.type isnt 'NEWLINE'
              me.throwError "expected: ','|then|NEWLINE not #{me.lexer.token}"
            me.body = me.req(Body)

        #end if

control: "if"-"else" are related by having the same indent

        if me.lexer.token.value is 'else'

          if me.lexer.index isnt 0 
            me.throwError 'expected "else" to start on a new line'

          if me.lexer.indent < me.indent
            #token is 'else' **BUT IS LESS-INDENTED**. It is not the "else" to this "if"
            return

          if me.lexer.indent > me.indent
            me.throwError "'else' statement is over-indented"

        #end if

        me.elseStatement = me.opt(ElseIfStatement, ElseStatement)


ElseIfStatement
---------------

`ElseIfStatement: (else|otherwise) if Expression Body`

This class handles chained else-if statements

    class ElseIfStatement inherits from ASTBase
/!
      
      properties nextIf
!/

      method parse()

        me.reqValue 'else', 'otherwise'
        me.reqValue 'if'
        me.lock()

return the consumed 'if', to parse as a normal 'IfStatement'

        me.lexer.returnToken()
        me.nextIf = me.req(IfStatement)


ElseStatement
-------------
`ElseStatement: ('else'|'otherwise') (Statement | Body) `

This class handles closing "else" statements

    class ElseStatement inherits from ASTBase
/!
      
      properties body
!/
      
      method parse()

        me.reqValue 'else','otherwise'
        me.lock()
        me.body = me.req(Body)


Loops
=====

LiteScript provides the standard js and C `while` loop, but also provides a `until` loop
and a post-condition `do loop while|until`


## WhileUntilExpression

common symbol for loops conditions. Is the word 'while' or 'until' followed by a boolean-Expression

`WhileUntilExpression: ('while'|'until') boolean-Expression`

    class WhileUntilExpression inherits from ASTBase
/!
      
      properties expr
!/

      method parse()
        me.name = me.reqValue('while','until')
        me.lock()
        me.expr = me.req(Expression)



DoLoop
------

`DoLoop: do [pre-WhileUntilExpression] [":"] Body loop [post-WhileUntilExpression]`

do-loop has optional pre-condition and optional post-condition

###Case 1) do-loop without any condition

a do-loop without any condition is an *infinite loop* (usually with a `break` statement inside)

Example:
/*
  var x=1
  
  do:

    x++
    print x
    when x is 10, break

  loop
*/

###Case 2) do-loop with pre-condition

A do-loop with pre-condition, is the same as a while|until loop

Example:
/*
  var x=1
  
  do while x<10

    x++
    print x

  loop
*/

### Case 3) do-loop with post-condition

A do-loop with post-condition, execute the block, at least once, and after each iteration, 
checks the post-condition, and loops `while` the expression is true
*or* `until` the expression is true 

Example:
/*
  var x=1
  
  do:

    x++
    print x

  loop until x is 10
*/

### Case 4) loop with both, pre and post-conditions.

You can create a do-loop with both conditions, pre and post, **but this is dicouraged** since it affects code-flow
understanding. 

For maximun readability, you should choose a loop construction with the followin rules:

A) For single-condition loops

  1) Use a `while` loop
  2) Use a `until` loop
  3) Use a `do: ... loop while|until` 

B) For multi-condition loops

  1) Use the previous list, add: `if condition, break` to the loop body.


### Implementation

    class DoLoop inherits from ASTBase
/!
      
      properties preWhileUntilExpression,body,postWhileUntilExpression
!/

      method parse()
        
        me.reqValue 'do'

        if me.optValue('nothing')
          me.throwParseFailed('is do nothing')

        me.optValue ":"
        me.lock()

Get optional pre-condition

        me.preWhileUntilExpression = me.opt(WhileUntilExpression)

        me.body = me.opt(Body)

        me.reqValue "loop"

Get optional post-condition

        me.postWhileUntilExpression = me.opt(WhileUntilExpression)


WhileUntilLoop
--------------

`WhileUntilLoop: pre-WhileUntilExpression Body`

Execute the block `while` the condition is true or `until` the condition is true 

while|until loops are simpler forms of loops. The `while` form, is the same as in C and js.

WhileUntilLoop derives from DoLoop, to use its `.produce()` method (it is a simple form of DoLoop)

    class WhileUntilLoop inherits from DoLoop
/!
      
      properties preWhileUntilExpression, body
!/

      method parse()
        
        me.preWhileUntilExpression = me.req(WhileUntilExpression)
        me.lock()

        me.body = me.opt(Body)


LoopControlStatement
--------------------

`LoopControlStatement: (break|continue)`

This handles the `break` and `continue` keywords.
'continue' jumps to the start of the loop (as C & Js: 'continue')

    class LoopControlStatement inherits from ASTBase
/!
      
      properties control
!/

      method parse()
        me.control = me.reqValue('break','continue')


DoNothingStatement
------------------

`DoNothingStatement: do nothing`

    class DoNothingStatement inherits from ASTBase
      method parse()
        me.reqValue 'do'
        me.reqValue 'nothing'
        me.lock()



For Statement
=============

    class ForStatement inherits from ASTBase
/!
      
      properties variant
!/

      method parse()
/!
      
        declare valid me.createScope
!/

We start with commonn `for...` code

        me.reqValue 'for'
        me.lock()

Create a scope, for index and value vars 

        me.createScope()

There are 3 variants of `ForStatement` in LiteScript,
we now require one of them

        me.variant = me.req(ForEachProperty,ForIndexNumeric,ForEachInArray)


##Variant 1) **for each property** to loop over **object property names**

Grammar:
`ForEachProperty: for each [own] property name-NameDeclaration in object-VariableRef`

where `name-VariableDecl` is a variable declared on the spot to store each property name,
and `object-VariableRef` is the object having the properties 

if the optional `own` keyword is used, only instance properties will be looped 
(no prototype chain properties)

    class ForEachProperty inherits from ASTBase
/!
      
      properties ownOnly,indexVar,iterable, body
!/

      method parse()
/!
      
        declare valid me.addToScope
        declare valid me.globalVar
        declare valid me.addToScope

!/

        me.reqValue('each')

then check for optional `own`

        me.ownOnly = me.ifOptValue('own')

next we require: 'property', and lock.

        me.reqValue('property')  
        me.lock()

Get index variable name (to store property names), register index var in the scope

        me.indexVar = me.req(NameDeclaration)
        me.addToScope me.indexVar,{type:me.globalVar("String").members.prototype}

Then we require `in`, then the iterable-Expression (a object)

        me.reqValue 'in'
        me.iterable = me.req(Expression)

Now, get the loop body

        me.body = me.req(Body)


##Variant 2) **for index=...** to create **numeric loops**

This `for` variant is just a verbose expressions of the standard C (and js) `for(;;)` loop

Grammar:
`ForIndexNumeric: for index-NameDeclaration = start-Expression [,|;] (while|until) condition-Expression [(,|;) increment-Statement]`

where `index-VariableDecl` is a numeric variable declared on the spot to store loop index,
`start-Expression` is the start value for the index (ussually 0)
`condition-Expression` is the condition to keep looping (`while`) or to end looping (`until`)
and `increment-Statement` is the statement used to advance the loop index. If ommited the default is `index++`

Note: You can use comma or semicolons between the expressions.

    class ForIndexNumeric inherits from ASTBase
/!
      
      properties 
        indexVar,startIndex,conditionPrefix,endExpression,increment,body
!/

      method parse()

/!
      
        declare valid me.addToScope
!/

we require: a variable, a "=", and a value

        me.indexVar = me.req(NameDeclaration)
        me.reqValue "="
        me.lock()
        me.startIndex = me.req(Expression)

        me.addToScope me.indexVar

comma|semicolon are optional

        me.optValue ',',";"

get 'while|until|to' and condition

        me.conditionPrefix = me.reqValue('while','until','to')
        me.endExpression = me.req(Expression)

if a comma is next, expect Increment-Statement

        if me.optValue(',',";")
          me.increment = me.req(SingleLineStatement)

Now, get the loop body

        me.body = me.req(Body)


##Variant 3) **for each in** to loop over **Array indexes and items**

Grammar:
`ForEachInArray: for [each] [index-NameDeclaration,]item-NameDeclaration in array-VariableRef`

where:
* `index-VariableDecl` is a variable declared on the spot to store each item index (from 0 to array.length)
* `item-VariableDecl` is a variable declared on the spot to store each array item (array[index])
and `array-VariableRef` is the array to iterate over

    class ForEachInArray inherits from ASTBase
/!
      
      properties 
        mainVar:NameDeclaration
        indexVar:NameDeclaration
        iterable
        body
!/

      method parse()
/!
      
        declare valid me.iterable.root.name.referencedName.itemType
        declare valid me.addToScope
!/


first, optional 'each'

        me.optValue('each')

Get index variable and value variable.
Keep it simple: index and value are always variables declared on the spot

        me.mainVar = me.req(NameDeclaration)

a comma means: previous var was 'index', so register as index and get main var
  
        if me.optValue(',')
          me.indexVar = me.mainVar
          me.addToScope me.indexVar

          me.mainVar = me.req(NameDeclaration)

        else if me.optValue('at')
          me.indexVar = me.req(NameDeclaration)
          me.addToScope me.indexVar

        #end if           

we now *require* `in` and the iterable (array)

        me.reqValue 'in'
        me.lock()
        me.iterable = me.req(Expression)

Set mainvar type to iterator item-type, register main var in scope
  
        if me.iterable.root.name instanceof VariableRef and me.iterable.root.name.referencedName and me.iterable.root.name.referencedName.itemType
          me.mainVar.type = me.iterable.root.name.referencedName.itemType
        me.addToScope me.mainVar

and then, get the loop body

        me.body = me.req(Body)


--------------------------------

## AssignmentStatement

`AssignmentStatement: VariableRef ("="|"+="|"-="|"*="|"/=") Expression`

    class AssignmentStatement inherits from ASTBase
/!
      
      properties lvalue, rvalue
!/

      method parse()
/!
      
        declare valid this.scopeEvaluateAssignment
        declare valid me.parent.preParsedVarRef
        declare valid me.scopeEvaluateAssignment
        declare valid me.lvalue.referencedName
!/

        if me.parent.preParsedVarRef
          me.lvalue   = me.parent.preParsedVarRef # pass VariableRef already parsed
        else
          me.lvalue   = me.req(VariableRef)

require an assignment symbol: ("="|"+="|"-="|"*="|"/=")

        me.name = me.req('ASSIGN')
        me.lock()

        if me.lexer.token.type is 'NEWLINE' #dangling assignment
          me.rvalue   = me.req(FreeObjectLiteral) #assume Object Expression in freeForm mode
        else
          me.rvalue   = me.req(Expression)

if it's a direct assignment (=), evaluate assignment to:
* recognize x = require('y') and `import` the module constructing the dependency tree
* recognize module.exports = x as alias to `public` ans export the value
* assume types on simple assignments: `var x=new myClass` x.type=MyClass.name

        if me.name is '='
          me.scopeEvaluateAssignment(me.lvalue, me.lvalue.referencedName, me.rvalue)


## VariableRef

`VariableRef: ('--'|'++') IDENTIFIER (PropertyAccess|IndexAccess|FunctionAccess)* ('--'|'++')`

`VariableRef` is a Variable Reference

a VariableRef can include chained 'Accessors', which do:
* access a property of the object : `.`-> **PropertyAccess** and `[...]`->**IndexAccess**
* assume the variable is a function and perform a function call :  `(...)`->**FunctionAccess**

    class VariableRef inherits from ASTBase
/!
      
      properties 
        preIncDec,varName:NameDeclaration, accessors,postIncDec
        executes,hasSideEffecs
        referencedName

      declare thisClass
      declare valid thisClass.parentClass.name
!/

      method parse()

        me.preIncDec = me.optValue('--','++')

get var name, translate common aliases (me->this)
/!

        declare valid me.getDeclaration
        declare mainVarName:string
!/

        me.executes = false

        var mainVarName = me.req('IDENTIFIER')
        mainVarName = mainVarName.translate(IDENTIFIER_ALIASES)

        me.lock()

replace 'super' by '<SuperClass>.prototype'
    
        if mainVarName is 'super'
          var thisClass = me.getParent(ClassDeclaration)
          if no thisClass
            me.throwError "can't use 'super' outside a class method"
          me.varName = thisClass.parentClass
          me.lexer.returnToken()
          me.lexer.insertTokens([{value:'.'},{type:'IDENTIFIER',value:'prototype'}])

else (not lexical 'super')
var name should be in the scope
Note: *getDeclaration()* Always return a NameDeclaration. 
It emits error and create a dummy one if not found.

        else
          me.varName = me.getDeclaration(mainVarName)

          if mainVarName is 'null'
            me.executes = true #allow 'null' on its own line as alias to 'do nothing'        

        me.referencedName = me.varName #default value. Accessors.parse() can change it

Now we check for accessors: 
`.`->**PropertyAccess** 
`[...]`->**IndexAccess** 
`(...)`->**FunctionAccess**
Note: Accessors.parse will:
* Check for valid property names
* if the accessors are `., property access, the last property will be assigned to me.referencedName
* set parent.hasSideEffects=true if there are a function accessor
* set parent.executes=true if the last accessor is a function accessor
(performance) only if the next token in ".[(", parse Accessors

        if me.lexer.token.value in ".[("
          me.accessors = me.req(Accessors)

check for post-fix increment/decrement

        me.postIncDec = me.optValue('--','++')

If this variable ref has ++ or --, IT IS CONSIDERED a "call to execution" in itself, 
a "imperative statement", because it has side effects. 
for example: `i++` has a "imperative" part, It means: "give me the value of i, and then increment it!")

        if me.preIncDec or me.postIncDec 
          me.executes = true
          me.hasSideEffecs = true

Note: In LiteScript, *any VariableRef standing on its own line*, it's considered 
a function call. A VariableRef on its own line means "execute this!",
so, when translating to js, it'll be translated as a function call, and `()` will be added.
If the VariableRef is marked as 'executes' then it's assumed 
it is a statementin itself, so `()` will NOT be added.

Examples:
---------
    LiteScript   | Translated js  | Notes
    -------------|----------------|-------
    start        | start();       | "start", on its own, is considered a function call
    start(10,20) | start(10,20);  | Normal function call
    start 10,20  | start(10,20);  | function call w/o parentheses
    start.data   | start.data();  | start.data, on its own, is considered a function call
    i++          | i++;           | i++ is marked "executes", it is a statement in itself
    null         | null;          | null is accepted alias to 'do noting'


Check for 'require' calls, 'import' module

        if mainVarName is 'require'
            if me.executes and me.accessors.list[0] instanceof FunctionAccess
              var requireCall = me.accessors.list[0]
              if requireCall.args[0].root.name instanceof StringLiteral

get import paramter, and parent Module

                var importParameter = requireCall.args[0].root.name.getValue()
                var thisModule = me.getParent(Module)

                thisModule.required.push(importParameter)

'import' the required module (recursive compilation)
`importModule` is a method of 'Project' (MainModule parent)

                try
                  var root = me.getRootNode()
                  var importedModule = root.parent.importModule(thisModule, importParameter)
                  thisModule.imported.push(importedModule)

Assign module exports as this varRef 'returnType'

                  if importedModule.exports
                    me.returnType = importedModule.exports

                catch e
                  #include source position in error message
                  e.message = me.lexer.posToString()+". "+e.message
                  throw e


---------------------------------
This methos is only valid to be used in error reporting function accessors
will be output as "(...)", and index accessors as [...]

      method toString()

        var result = (me.preIncDec or "") + me.varName.name
        if me.accessors
          for ac in me.accessors.list
            result += ac.toString()
        return result + (me.postIncDec or "")

-----------------------

PropertyAccess
--------------

`.` -> PropertyAccess: get the property named "n" 

`PropertyAccess: '.' IDENTIFIER`

    class PropertyAccess inherits from ASTBase

      method parse()
        
        me.reqValue('.')
        me.lock()
        me.name = me.req(NameDeclaration) 

      method toString()
/!

        declare valid me.name.name
!/      

        return '.'+me.name.name

IndexAccess
-----------

`[n]`-> IndexAccess: get the property named "n" / then nth index of the array
                       It resolves to the property value

`IndexAccess: '[' Expression ']'`

    class IndexAccess inherits from ASTBase

      method parse()
        
        me.reqValue "["
        me.lock()
        me.name = me.req( Expression )
        me.reqValue "]" #closer ]

      method toString()
        return '[...]'

FunctionAccess
--------------

`(...)` -> FunctionAccess: The object is assumed to be a function, and the code executed. 
                           It resolves to the function return value.

`FunctionAccess: '(' [Expression,]* ')'`

    class FunctionAccess inherits from ASTBase
/!
      
      properties args
!/

      method parse()
        
        me.reqValue "("
        me.lock()
        me.args = me.optSeparatedList( Expression, ",", ")" ) #comma-separated list of expressions, closed by ")"

      method toString()
        return '(...)'

## Accessors

`Accessors: (PropertyAccess|FunctionAccess|IndexAccess)`

Accessors are: 
  `PropertyAccess: '.' IDENTIFIER`
  `IndexAccess:    '[' Expression ']'`
  `FunctionAccess: '(' [Expression,]* ')'`

Accessors can appear after a VariableRef (most common case)
but also after a String constant, a Regex Constant,
a ObjectLiteral and a ArrayLiteral 

Examples:
  myObj.item.fn(call)  <-- 3 accesors, two PropertyAccess and a FunctionAccess
  myObj[5](param).part  <-- 3 accesors, IndexAccess, FunctionAccess and PropertyAccess
  [1,2,3,4].indexOf(3) <-- 2 accesors, PropertyAccess and FunctionAccess


Actions:
`.`-> PropertyAccess: Search the property in the object and in his pototype chain.
                      It resolves to the property value

`[...]` -> IndexAccess: Same as PropertyAccess

`(...)` -> FunctionAccess: The object is assumed to be a function, and the code executed. 
                      It resolves to the function return value.

    class Accessors inherits from ASTBase
/!
      
      properties list
!/

      method parse()

We store the accessors in the property: .list
if the accessors node exists, .list will have **at least one item**

        me.list = []
/!
      
        declare ac:Accessors
        declare ownerVar:NameDeclaration
        
        declare valid ac.name.name
        declare valid ac.keyword
        declare valid me.getValidProperty
        declare valid me.parent.referencedName
        declare valid me.parent.executes
        declare valid me.parent.hasSideEffects
        declare valid me.parent.varName
!/

Starting main variable name, to check property names

        var ownerVar = me.parent.varName 
        var skipChecks = false

        while true

get accessor

            var ac = me.parseDirect(me.lexer.token.value, AccessorsDirect)
            if no ac 
              break

Store parsed accessor

            me.list.push(ac)

for PropertyAccess, check if the property name is valid 
also set VariableRef.referencedName to last accessed property
Example: myvar.x.y.z => referencedName = z (member of y, member of x, member of scope var myvar)

            if ac instanceof PropertyAccess

              if ownerVar and not skipChecks 
                if ownerVar.name is 'exports' or ownerVar.name is 'prototype'
                  skipChecks = true
                else
                  ac.name = me.getValidProperty(ownerVar, ac.name)

              me.parent.referencedName = ac.name #last property access is the referenced name 
              ownerVar = ac.name # for the next accessor, this ac is its owner

else, if IndexAccess or FunctionAccess: we stop check valid property names
also we dont know the referenced name (here, at compile time)
we dont know the function call result or the item stored

            else
              ownerVar = undefined 
              me.parent.referencedName = undefined 
              skipChecks = true

if the very last accesor is "(", it means the entire expression is a function call,
it's a call to "execute code", so it's a imperative statement on it's own.
if any accessor is a function call, this statement is assumed to have side-effects

            me.parent.executes = ac.keyword is "("
            if me.parent.executes
              me.parent.hasSideEffects = true

        #loop, continue parsing accesors

        if me.list.length is 0 
          me.throwParseFailed "no accessors found"

        return


-----------------------

Operand
-------

`Operand:
  (NumberLiteral|StringLiteral|RegExpLiteral
  |ParenExpression|ArrayLiteral|ObjectLiteral
  |FunctionDeclaration
  |VariableRef) [Accessors]*

Examples:

4 + 3 : Operand Oper Operand
-4    : UnaryOper Operand

A `Operand` is the data on which the operator operates.
It's the left and right part of a binary operator.
It's the data affected (righ) by a UnaryOper.

To make parsing faster, associate a token type/value,
with exact AST class to call parse() on.

    var OPERAND_DIRECT_TYPE = {'STRING': StringLiteral,
      'NUMBER': NumberLiteral,
      'REGEX': RegExpLiteral
    }

    var OPERAND_DIRECT_TOKEN = {'(':ParenExpression,
      '[':ArrayLiteral,
      '{':ObjectLiteral,
      'function': FunctionDeclaration
    }

    class Operand inherits from ASTBase
/!
      
      properties accessors
!/

      method parse()

if it's a NUMBER: it is NumberLiteral, if it's a STRING: it is StringLiteral (also for REGEX)
or, upon next token, cherry pick which AST nodes to try,
'(':ParenExpression,'[':ArrayLiteral,'{':ObjectLiteral,'function': FunctionDeclaration

        me.name = me.parseDirect(me.lexer.token.type, OPERAND_DIRECT_TYPE) or me.parseDirect(me.lexer.token.value, OPERAND_DIRECT_TOKEN)

if it is a literal ParenExpression or FunctionDeclaration
besides base value, operands can have accessors. For example: `"string".length` , `myObj.fn(10)`
Now we check for accessors: `.`->**PropertyAccess** `[...]`->**IndexAccess** `(...)`->**FunctionAccess**
(performance) only if the right token. 
Note: [Accessors] can set: parent.referencedName, parent.executes and parent.hasSideEffects

        if me.name 

            if me.lexer.token.value in ".[("
              me.accessors = me.opt(Accessors)

else, (if not literal, ParenExpression or FunctionDeclaration)
it must be a variable ref

        else
            me.name = me.req(VariableRef)

        #end if

    #end Operand


Oper
----

`Oper: (bitwise(and|or|xor)|>>|<<
        |'^'|'*'|'/'|'+'|'-'|mod
        |([is]instance of|instanceof)
        |'>'|'<'|'>='|'<='|is|'==='|isnt|is not|!=='
        |and|but|or
        |not|in
        |has property
        |? true-Expression : false-Expression)`

An Oper sits between two Operands ("Oper" is a "Binary Operator", different from *UnaryOperators* which optionally precede a Operand)

If an Oper is found after an Operand, a second Operand is expected.

Operators can include:
* arithmetic operations "*"|"/"|"+"|"-"
* boolean operations "and"|"or"
* `in` collection check.  (js: `indexOx()>=0`)
* instance class checks   (js: instanceof)
* short-if ternary expressions ? :
* bit operations (bitwise/shift)
* `has property` object property check (js: `propName in object`)

    class Oper inherits from ASTBase
/!
      
      properties 
        negated
        left:Operand,right:Operand
        pushed,precedence

!/

      method parse()

/!
      
        declare valid me.calcPrecedence
!/


Get next token, require an OPER

        me.name = me.req('OPER')
        me.lock() 

A) validate double-word opers

A.1) validate `instance of`

        if me.name is 'instance'
            me.name += ' '+me.reqValue('of')

A.2) validate `has|hasnt property`

        else if me.name is 'has'
            me.name += ' '+me.reqValue('property')

        else if me.name is 'hasnt'
            me.negated = true # set the 'negated' flag
            me.name += 'has '+me.reqValue('property')

A.3) validate `bitwise`

        if me.name is 'bitwise'
            me.name += ' '+me.reqValue('and','or','xor')

A.4) also, check if we got a `not` token.
In this case we require the next token to be `in` 
`not in` is the only valid (not-unary) *Oper* starting with `not`

        else if me.name is 'not'
          me.negated = true # set the 'negated' flag
          me.name = me.reqValue('in') # require 'not in'

B) Synonyms 

else, check for `isnt`, which we treat as `!==`, `negated is` 

        else if me.name is 'isnt'
          me.negated = true # set the 'negated' flag
          me.name = 'is' # treat as 'Negated is'

else check for `instanceof`, (old habits die hard)

        else if me.name is 'instanceof'
          me.name = 'instance of'

        #end if

C) Variants on 'is...'

        if me.name is 'is'

  C.1) is not
  Check for `is not`, which we treat as `isnt` rather than `is ( not`.

          if me.optValue('not') # --> is not...
              me.negated = true # set the 'negated' flag

  C.2) accept 'is instance of'|'is instanceof'

          if me.optValue('instance')
              me.name = 'instance '+me.reqValue('of')
          else if me.optValue('instanceof')
              me.name = 'instance of'

        #end if

end special 'is' treatment

calculate operator precedence

        me.calcPrecedence()

      #end Oper parse


###calcPrecedence:

**Helper method to get Precedence Index (lower number means higher precedende)**

      method calcPrecedence()

        me.precedence = operatorsPrecedence.indexOf(me.name)
        if me.precedence is -1 
            debugger
            fail with "OPER '#{me.name}' not found in the operator precedence list"


###Boolean Negation: `not`
####Notes for the javascript programmer


In LiteScript, the *boolean negation* `not`, 
has LOWER PRECEDENCE than the arithmetic and logical operators.

In LiteScript: `if not a + 2 is 5` means `if not (a+2 is 5)`

In javascript: `if ( ! a + 2 === 5 )` means `if ( (!a)+2 === 5 )` 

so remember not to mentally translate `not` to js `!`


UnaryOper
---------

`UnaryOper: ('-'|new|type[" "]of|not|no|bitwise not) `

A Unary Oper is an operator acting on a single operand.
Unary Oper inherits from Oper, so both are `instance of Oper`

Examples:
1) `not`     *boolean negation*     `if not a is b`
2) `-`       *numeric unary minus*  `-(4+3)`
2) `+`       *numeric unary plus*   `+4` (can be ignored)
3) `new`     *instantiation*        `x = new classes[2]()`
4) `type of` *type name access*     `type of x is 'string'` 
5) `no`      *'falsey' check*       `if no options then options={}` 
6) `bitwise not` *bit-unary-negation* `a = bitwise not xC0 + 5`

    class UnaryOper inherits from Oper

      method parse()

          me.name = me.reqValue('new','+','-','not','no','typeof','type','bitwise')

Check for `type of` - we allow "type" as var name, but recognize "type of" as UnaryOper

          if me.name is 'type'
              if me.optValue('of')
                me.name = 'type of'
              else
                me.throwParseFailed 'expected "of" after "type"'
                    
Lock, we have a unary pre-operator

          me.lock()

Rename - and + to 'unary -' and 'unary +'
'typeof' to 'type of'

          if me.name is '-'
            me.name = 'unary -'

          else if me.name is '+'
            me.name = 'unary +'

          else if me.name is 'typeof'
              me.name = 'type of'

if its 'bitwise', must be 'bitwise not' for an UnaryOper

          else if me.name is 'bitwise' 
              me.name += ' ' + me.reqValue('not')

          #end if

calculate precedence - Oper.calcPrecedence()

          me.calcPrecedence()

      #end parse 


-----------
## Expression

`Expression: [UnaryOper] Operand [Oper [UnaryOper] Operand]*`

The expression class parses intially a *flat* array of nodes.
After the expression is parsed, a *Expression Tree* is created based on operator precedence.

    class Expression inherits from ASTBase
/!
      
      properties operandCount, root
!/
 
      method parse()

/!
      
        declare valid me.growExpressionTree
        declare valid me.root.name.type
!/

        var arr = []
        me.operandCount = 0 

        while true

Get optional unary operator

          var unary = me.opt(UnaryOper)

          if unary
            arr.push(unary)
            me.lock()

Get operand

          arr.push( me.req(Operand) )
          me.operandCount += 1 
          me.lock()

(performance) Fast exit for common tokens: `=` `,` and `)` means end of expression.

          if me.lexer.token.type is 'ASSIGN' or me.lexer.token.value in [')',','] 
              break

optional newline **before** Oper
To allow a freeForm mode on expressions, we look ahead, and if the first token in the next line is OPER
we consume the NEWLINE, allowing multiline expressions. The exception is ArrayLiteral, brecause in fre-form mode
the next item in the array, can start with a unary operator

          if me.lexer.token.type is 'NEWLINE' and not (me.parent instanceof ArrayLiteral)
            me.opt 'NEWLINE' #consume newline
            if me.lexer.token.type isnt 'OPER' # the first token in the next line isnt OPER (+,and,or,...)
              me.lexer.returnToken() # return NEWLINE
              break #end Expression

Try to parse next token as an operator

          var operator = me.opt(Oper)
          if operator

If it was an (binary) operator, store, and continue because we expect another operand

            arr.push(operator)

(dangling expresion) if an oper is left at the end of a line, the expression continues on the next line

            me.opt 'NEWLINE' #optional newline after Oper

            continue

          else
            
            break # no more operators, end of expression

          #end if

        #loop


Now we analize precedence, and create a tree from me.arr[]

        me.growExpressionTree(arr)

(prettier generated code)if it's only one operand we give the expression the type of the operand

        if me.operandCount is 1 
          me.type = me.root.name.type

      #end method Expression.parse()


Grow The Expression Tree
========================

Growing the expression AST
--------------------------

By default, for every expression, the parser creates a *flat array*
of UnaryOper, Operands and Operators.

`Expression: [UnaryOper] Operand [Oper [UnaryOper] Operand]*`

For example, `not 1 + 2 * 3 is 5`, turns into:

me.arr =  ['not','1','+','2','*','3','is','5']

In this method we create the tree, by pushing down operands, 
according to operator precedence.

Te process runs until there is only one operator left in the root node 
(the one with lower precedence)

For example, `not 1 + 2 * 3 is 5`, turns into:

<pre>
>   not
>      \
>      is
>     /  \
>   +     5
>  / \   
> 1   *  
>    / \ 
>    2  3
</pre>


`3 in a and not 4 in b`
<pre>
>      and
>     /  \
>   in    not
>  / \     |
> 3   a    in
>         /  \
>        4   b
</pre>

`3 in a and 4 not in b`
<pre>
>      and
>     /  \
>   in   not-in
>  / \    / \
> 3   a  4   b
>         
</pre>

`-(4+3)*2`
<pre>
>   *
>  / \
> -   2
>  \
   +
  / \
 4   3
</pre>

Expression.growExpressionTree()
-------------------------------

      method growExpressionTree(arr:array)

/!

        declare debug
        declare item
        declare valid item.name.name
        declare valid item.pushed
        declare valid item.precedence

!/

while there is more than one operator in the root node...

        while arr.length > 1

find the one with highest precedence (lower number) to push down
(on equal precedende, we use the leftmost)

          compile if debug
            var d="Expr.TREE: "
            for item at inx in arr
              if item instanceof Oper
                d+=" "+item.name
                if item.pushed 
                    d+="-v"
                d+=" "
              else
                d+=" "+item.name.name
            debug d
          end compile

          var pos=-1
          var minPrecedenceInx = 100
          for item at inx in arr

            debug "item at #{inx} #{item.name}, Oper? #{item instanceof Oper}. precedence:",item.precedence

            if item instanceof Oper
              if not item.pushed and item.precedence < minPrecedenceInx
                pos = inx
                minPrecedenceInx = item.precedence

          #end for
          
          #control
          if pos<0
            me.throwError("can't find high precedence operator")

Un-flatten: Push down the operands a level down

          var oper = arr[pos]

          oper.pushed = true

          if oper instanceof UnaryOper

            #control
            compile if debug
              if pos is arr.length
                me.throwError("can't get RIGHT operand for unary operator '#{oper}'") 
            end compile

            # if it's a unary operator, take the only (right) operand, and push-it down the tree
            oper.right = arr.splice(pos+1,1)[0]

          else

            #control
            compile if debug
              if pos is arr.length
                me.throwError("can't get RIGHT operand for binary operator '#{oper}'")
              if pos is 0
                me.throwError("can't get LEFT operand for binary operator '#{oper}'")
            end compile

            # if it's a binary operator, take the left and right operand, and push-them down the tree
            oper.right = arr.splice(pos+1,1)[0]
            oper.left = arr.splice(pos-1,1)[0]

          #end if

        #loop until there's only one operator

Store the root operator

        me.root = arr[0]

      #end method

-----------------------

## Literal

This class groups: NumberLiteral, StringLiteral, RegExpLiteral, ArrayLiteral and ObjectLiteral

    class Literal inherits from ASTBase
/!
  
      properties referencedName:NameDeclaration, type:NameDeclaration
      
!/

      method getClass()
        fail with 'abstract'      

      method getValue()
        return me.name

      method setType()
        me.referencedName = me.getClass()
        me.type = me.referencedName.ownMember('prototype')


NumberLiteral
-------------

`NumberLiteral: NUMBER`

A numeric token constant. Can be anything the lexer supports, including scientific notation
, integers, floating point, or hex.

    class NumberLiteral inherits from Literal
      method parse()
        me.name = me.req('NUMBER')
        me.setType()

      method getClass()
        return me.globalVar('Number')


StringLiteral
-------------

`StringLiteral: STRING`

A string constant token. Can be anything the lexer supports, including single or double-quoted strings. 
The token include the enclosing quotes

    class StringLiteral inherits from Literal
      method parse()
        me.name = me.req('STRING')
        me.setType()

      method getClass()
        return me.globalVar('String')

      method getValue()
        return me.name.slice(1,-1) #remove quotes

RegExpLiteral
-------------

`RegExpLiteral: REGEX`

A regular expression token constant. Can be anything the lexer supports.

    class RegExpLiteral inherits from Literal

      method parse()
        me.name = me.req('REGEX')
        me.setType()

      method getClass()
        return me.globalVar('RegExp')


ArrayLiteral
------------

`ArrayLiteral: '[' (Expression,)* ']'`

/*

An array definition, such as `a = [1,2,3]`
or 

```
a = [
   "January"
   "February"
   "March"
  ]
```

*/

    class ArrayLiteral inherits from Literal
/!

      properties items
!/

      method parse()
        me.reqValue '['
        me.lock()
        me.name = me.declareName("[ArrayLiteral]#{me.positionText()}")
        me.items = me.optSeparatedList(Expression,',',']') # closer "]" required
        me.setType()

      method getClass()
        return me.globalVar('Array')


## ObjectLiteral

`ObjectLiteral: '{' NameValuePair* '}'`

Defines an object with a list of key value pairs. This is a JavaScript-style definition.

`x = {a:1,b:2,c:{d:1}}`

    class ObjectLiteral inherits from Literal
/!

      properties items
!/

      method parse()

        me.reqValue '{'

        me.lock()

        me.items = me.optSeparatedList(NameValuePair,',','}') # closer "]" required
        me.setType()


      method getClass()
        return me.globalVar('Object')


FreeObjectLiteral
-----------------

Defines an object with a list of key value pairs. 
Each pair can be in it's own line. A indent denotes a new level deep.
FreeObjectExpressions are triggered by a "danglin assignment"

Examples: 
/*

    var x =            // <- dangling assignment
          a: 1 
          b:           // <- dangling assignment
            b1:"some"
            b2:"cofee"


    var x =
     a:1
     b:2
     c:
      d:1
     months: ["J","F",
      "M","A","M","J",
      "J","A","S","O",
      "N","D" ]


    var y =
     c:{d:1}
     trimester:[
       "January"
       "February"
       "March"
     ]
     getValue: function(i)
       return y.trimester[i]
*/

    class FreeObjectLiteral inherits from ObjectLiteral
/!

      properties indent,items
!/

      method parse()
        me.lock()

get items: optional comma separated, closes on de-indent, at least one required

        me.indent = me.parent.indent #everything with more indent than the parent node
        me.items = me.reqSeparatedList(NameValuePair,',') 
        me.setType()


NameValuePair
-------------

`NameValuePair: (IDENTIFIER|STRING|NUMBER) ':' Expression`

A single definition in a `ObjectLiteral` 
a `property-name: value` pair.

    class NameValuePair inherits from ASTBase
/!

      properties value
!/

      method parse()
/!

        declare valid me.parent.name.addMember
!/

        me.name = me.req('IDENTIFIER','STRING','NUMBER')

        me.reqValue ':'
        me.lock()

if it's a "dangling assignment", we assume FreeObjectLiteral

        if me.lexer.token.type is 'NEWLINE'
          me.value = me.req(FreeObjectLiteral)
        else
          me.value = me.req(Expression)



ParenExpression
---------------

`ParenExpression: '(' Expression ')'`

An expression enclosed by parentheses, like `(a + b)`.

    class ParenExpression inherits from ASTBase
/!

      properties expr:Expression
!/

      method parse()
        me.reqValue '('
        me.lock()
        me.expr = me.req(Expression)
        me.reqValue ')'



## FunctionDeclaration

`FunctionDeclaration: 'function NameDeclaration ["(" [VariableDecl,]* ")"] [returns type-VariableRef] Body`

Functions: parametrized pieces of callable code.

    class FunctionDeclaration inherits from ASTBase
/!

      properties specifier,paramsDeclarations,body
!/

      method parse()

/!

        declare valid me.parent.isAdjectivated
!/


        me.specifier = me.reqValue('function')
        me.lock()

        me.name = me.opt(NameDeclaration) 

if it is not anonymous, add function name to parent scope
if its 'public' add to exports

        if me.name
          me.addToScope me.name
          if me.parent.isAdjectivated('public')
            me.addToExport me.name

A function has a scope for vars declared in it's body
Starts populated by 'this' and 'arguments.length'

        me.createFunctionScope()

get parameter members, and function body

        me.parseParametersAndBody()

      #end parse


###parseParametersAndBody()

This method is shared by functions, constructors and methods

      method parseParametersAndBody()

if there are no `()` after `function`, we assume `()`

        if me.lexer.token.type is 'NEWLINE' #-> assume "()" (no parameters)
            null

else, parse parameter members: `'(' [VariableDecl,] ')'`

        else 
            me.reqValue '('
            me.paramsDeclarations = me.optSeparatedList(VariableDecl,',',')')

            if me.optValue('returns')
              #auto-capitalize core classes
              if me.lexer.token.value in ['string','array','number','object','function','boolean']
                me.lexer.token.value = me.lexer.token.value[0].toUpperCase()+me.lexer.token.value.slice(1)
              me.returnType = me.req(VariableRef)
    
Add parameters names, to function scope

            me.addVarsToScope me.paramsDeclarations

now get function body
        
        me.body = me.req(Body)


## ClassDeclaration

`ClassDeclaration: class NameDeclaration [[","] prototype is VariableRef] Body`

Defines a new class with an optional parent class. properties and methods go inside the block.

    class ClassDeclaration inherits from ASTBase

/!

      properties
        name:NameDeclaration
        parentClass:NameDeclaration
        prototypeMember:NameDeclaration
        body
!/

      method parse()

/!

        declare valid me.name.name
        declare valid me.parent.isAdjectivated
        declare valid me.name.type
        declare valid me.name.addMember
!/

        me.reqValue 'class'
        me.lock()
        
        me.name = me.req(NameDeclaration)

A class in js, is a function

        me.name.type = me.globalVar('Function').members.prototype

Control: class names should be Capitalized

        if not String.isCapitalized(me.name.name)
            me.lexer.sayErr "class names should be Capitalized: class #{me.name}"

Add class name, to parent scope
    
        me.addToScope me.name
        if me.parent.isAdjectivated('public')
          me.addToExport me.name

Now parse optional `,(super is|extends)` setting the super class
(aka oop classic:'inherits', or ES6: 'extends')

/!

        declare 
          varRefSuper:VariableRef
          superPrototype:NameDeclaration

        declare valid me.parentClass.members.prototype
!/

        var varRefSuper

        me.optValue(',') 
        if me.optValue('super','extends') 
          me.optValue('is') 
          varRefSuper = me.req(VariableRef)
          me.parentClass = varRefSuper.referencedName


#old syntax support- REMOVE LATER

        if me.optValue('inherits') 
          me.reqValue('from')
          varRefSuper = me.req(VariableRef)

#end old syntax support


Get superclass prototype

        if varRefSuper 
          me.parentClass = varRefSuper.referencedName
          superPrototype = me.parentClass
          if me.parentClass.members.prototype #it's a class
            superPrototype = me.parentClass.members.prototype

        if not me.parentClass
          superPrototype = me.globalVar('Object').members.prototype

We create the 'Class.prototype' NameDeclaration
All class's properties & methods will be added to 'prototype' as valid member names.
'prototype' starts with 'constructor' which is the class-funcion itself

        me.name.addMember('prototype',{type:superPrototype}).addMember('constructor',{type:me.name}) 

Now get class body. All properties and methods will be added as members of 'protoype'

        me.body = me.opt(Body)
      
      #end parse 


## MethodDeclaration 

`MethodDeclaration: '(method|constructor) [name] ["(" (VariableDecl,)* ")"] Body`

A `method` is a function defined in the prototype of a class. 
A `method` has an implicit var `this` pointing to the specific instance the method is called on.

MethodDeclaration derives from FunctionDeclaration, so both are instance of FunctionDeclaration

    class MethodDeclaration inherits from FunctionDeclaration
      method parse()
/!

        declare valid me.name.type

        declare ownerObj:NameDeclaration, ownerObjFrom:string
        declare varRef: VariableRef

!/

        me.specifier = me.reqValue('method')
        me.lock()

require method name

        me.name = me.req(NameDeclaration)

a 'method' is a function

        me.name.type = me.globalVar('Function').members.prototype

Now get object to add function to: normally Class.prototype

        var ownerObj

#support old SYNTAX - REMOVE LATER - method xx **of** class

        #save pos
        var pos=me.lexer.getPos()

        while me.lexer.nextToken()

          if me.lexer.token.type is 'NEWLINE'
            break

          var lastInx = me.lexer.index

          # is 'of xxx' - create Grammar.AppendToDeclaration
          if me.optValue('of')

              me.lock()

              me.varRef = me.req(VariableRef)
              ownerObj= me.varRef.referencedName
              if not ownerObj.members or not ownerObj.members.prototype
                me.throwError 'of '+me.varRef.toString()+' no prototype found/not defined'

              if not me.varRef.accessors
                me.varRef.accessors = new Accessors(me)
                me.varRef.accessors.list=[]

              var protoPa = new PropertyAccess(me)
              protoPa.name = {name:'prototype'}
              me.varRef.accessors.list.push(protoPa)

              ownerObj = ownerObj.members.prototype

              #restore pos
              me.lexer.setPos pos
              #remove 'of'
              me.lexer.infoLine.tokens.splice(lastInx,20) #remove from tokens

        #loop

        me.lexer.setPos pos #restore pos

#end support old SYNTAX - 

        if no ownerObj

Get the object where this method should be attached to

          var parentClass = me.getParent(ClassDeclaration) #gets parent class/append to
          if no parentClass
            me.throwError "'method' declaration outside class/append declaration. Check indent"

          if parentClass instanceof AppendToDeclaration
            #  inside a "append to" -> assign to exact object
            ownerObj = parentClass.referenced
            me.varRef = parentClass.varRef #get varRef from append to, to out at function production
          else
            # inside a class -> assign to prototype
            ownerObj = parentClass.name.members.prototype

add method name to ownerObj as valid new member
also name.parent is ownerObj, so name.toString() = OwnerObj.name +'.'+ name

        ownerObj.addMember me.name
        me.name.parent = ownerObj

create method scope, initially populated by 'this'

        me.createFunctionScope(ownerObj)

now get parameters and body (as with any function)

        me.parseParametersAndBody()

      #end parse


## ConstructorDeclaration 

`ConstructorDeclaration : 'constructor ["(" (VariableDecl,)* ")"] Body`

A `constructor` is the main function of the class. In js is the function-class body  (js: `function Class(...){... `)
The `constructor` method is called upon creation of the object, by the `new` operator.
The return value is the value returned by `new` operator, that is: the new instance of the class.

ConstructorDeclaration derives from MethodDeclaration, so it is also a instance of FunctionDeclaration

    class ConstructorDeclaration inherits from MethodDeclaration
      method parse()

        me.specifier = me.reqValue('constructor')
        me.lock()

Get parent class NameDeclaration. The constructor function "represents" the class, is a function
whose name is the class name

        var parentClass = me.getParent(ClassDeclaration)
        if no parentClass
          me.throwError 'constructor found outside class declaration'
        me.name = parentClass.name

The constructor (as any function), has a 'scope'. It captures all vars declared in its body.
Create constructor scope, initially populated by 'this:me.name.members.prototype' 

        me.createFunctionScope(me.name.members.prototype)

now get parameters and body (as with any function)

        me.parseParametersAndBody()

      #end parse

------------------------------

## AppendToDeclaration

`AppendToDeclaration: append to (class|object) VariableRef Body`

Adds methods and properties to an existent object, e.g., Class.prototype

    class AppendToDeclaration inherits from ClassDeclaration
/!
      
      properties 
        referenced:NameDeclaration
        body
!/

      method parse()

        me.req 'append'
        me.req 'to'
        me.lock()

        var toWhat = me.req('class','object','namespace')
        me.optClass = toWhat is 'class'

        me.varRef = me.req(VariableRef)

we take the referenced name as our own, and since we're recognized as 
a 'ClassDeclaration', all methods and properties will be added 
to the referenced object

        me.referenced = me.varRef.referencedName

if optional 'class' keyword is present, we add to referenced.prototype

        if me.optClass

          if not me.referenced.members.prototype
            me.referenced.addMember('prototype')
            #me.lexer.sayErr "'#{me.varRef.toString()}' has no prototype"

          me.referenced = me.referenced.members.prototype

          if not me.varRef.accessors
            me.varRef.accessors = new Accessors(me)
            me.varRef.accessors.list=[]

          var protoPa = new PropertyAccess(me)
          protoPa.name = {name:'prototype'}
          me.varRef.accessors.list.push(protoPa)


Now get body. ('methods' & 'properties' will be added to referenced object

        me.body = me.req(Body)


FunctionCall
------------

`FunctionCall: VariableRef ["("] (Expression,) [")"]`

    class FunctionCall inherits from ASTBase
/!
      
      properties
          args
!/

      method parse(options)
/!

        declare valid me.parent.preParsedVarRef
        declare valid me.name.accessors
        declare valid me.name.executes
!/
Check for VariableRef. - can include (...) FunctionAccess

        if me.parent.preParsedVarRef #VariableRef already parsed
          me.name = me.parent.preParsedVarRef #use it
        else  
          me.name = me.req(VariableRef)

if the last accessor is function call, this is already a FunctionCall

        if me.name.accessors and me.name.executes
            return #already a function call

Here we assume is a function call without parentheses, a 'command'

        if me.lexer.token.type in ['NEWLINE','EOF']
          # no more tokens, let's asume FnCall w/o parentheses and w/o parameters
          return

else, get parameters

        me.args = me.optSeparatedList(Expression,",")



## DebuggerStatement

`DebuggerStatement: debugger`

When a debugger is attached, break at this point.

    class DebuggerStatement inherits from ASTBase
      method parse()
        me.name = me.reqValue("debugger")


## DeclareStatement

Declare statement allows you to forward-declare variable or object members. 
Also allows to declare the valid accessors for externally created objects
when you dont want to create a class to use as type.

`DeclareStatement: 'declare (VariableDecl,)+` #declare valid types: declare type:string, type:NameDeclaration
`DeclareStatement: 'declare valid VariableRef` #declare valid chains: declare valid me.type.name.name
`DeclareStatement: 'declare global (VariableDecl,)` #declare global vars
`DeclareStatement: 'declare on IDENTIFIER (VariableDecl,)` #declare members on vars
`DeclareStatement: 'declare [forward] (VariableDecl,)+` #deprecated.

    class DeclareStatement inherits from ASTBase
/!

      properties
        names:VariableDecl array

!/

      method parse()

        me.reqValue 'declare'
        me.lock()

/!

        declare 
          mainVarName:string
          mainVar:NameDeclaration
          propName:string
          inClass:ClassDeclaration

        declare valid mainVar.members.prototype
        declare valid inClass.name.members.prototype.ownMember
!/

        var mainVarName
        var mainVar
        var propName
        var parsed = false
        me.names = []

        if me.optValue('valid') 

          if me.lexer.token.value is ":"
            me.lexer.returnToken()
          else
            mainVarName = me.req('IDENTIFIER')
            mainVarName = mainVarName.translate(IDENTIFIER_ALIASES)
            mainVar = me.findInScope(mainVarName)
            if no mainVar
              me.throwError("add valid properties: '#{mainVarName}' not found in scope") 

            me.names.push mainVar
            var newMember
            while me.optValue('.')
              propName = me.req('IDENTIFIER')
              newMember = mainVar.ownMember(propName)
              if no newMember
                newMember = mainVar.addMember(propName)
              mainVar = newMember
              me.names.push newMember
            #loop
            parsed = true

        if not parsed 
          if me.optValue('on')

Find the main name where this properties are being forward-declared. 
If it doesnt exists, we create a "forward" declaration of the main var

              var varRef = me.req(VariableRef)

read names, add to referenced

              me.names = me.reqSeparatedList(VariableDecl,',')
              for varDecl in me.names
                varDecl.name.isForward = true
                varRef.referencedName.addMember varDecl.name

else (if no 'on' keyword), is a list to declare forward variable names on the scope
get list of declared names. Add the names to the intended scope
add to scope as forward declare var names

          else 

              var option = me.optValue('global','forward','name') or 'types'
              if option is 'name'
                  option = me.req('affinity')

              me.names = me.reqSeparatedList(VariableDecl,',')

              for varDecl in me.names
                if option is 'forward'
                  varDecl.name.isForward = true
                  me.addToScope varDecl.name
                else if option is 'global'
                  me.createGlobalVar varDecl.name.name


CompilerStatement
-----------------

`compiler` is a generic entry point to alter LiteScript compiler from source code.
It allows conditional complilation, setting compiler options, define macros(*)
and also allow the programmer to hook transformations on the compiler process itself(*).

(*) Not yet.

`CompilerStatement: (compiler|compile) (set|if|debugger|option) Body`

`set-CompilerStatement: compiler set (VariableDecl,)`

`conditional-CompilerStatement: 'compile if IDENTIFIER Body`

    class CompilerStatement inherits from ASTBase
/!

      properties
        kind, conditional:string
        body
        endLineInx
!/

      method parse()
/!

        declare list:VariableDecl array 
!/


        me.reqValue 'compiler','compile'
        me.lock()
        me.kind = me.reqValue('set','if','debugger','options')

### compiler set

        if me.kind is 'set'

get list of declared names, add to root node 'Compiler Vars'
            
            var list = me.reqSeparatedList(VariableDecl,',')
            for item in list

/!

              declare valid item.assignedValue.operandCount
              declare valid item.assignedValue.root.name
!/

              if item.assignedValue.operandCount > 1 
                me.throwError "compiler set: no expressions allowed"
              var operandValue = item.assignedValue.root.name

/!

              declare valid operandValue.varName.name
              declare valid operandValue.varName.hasOwnProperty
              declare valid operandValue.varName.value
              declare valid operandValue.getValue
!/

              var aValue=true
              if operandValue instanceof VariableRef
                if operandValue.varName.hasOwnProperty('value')
                  aValue = operandValue.varName.value
                else
                  me.throwError "compiler set: '#{operandValue.varName.name}' has no value at compile-time"
              else if operandValue instanceof Literal
                  aValue = operandValue.getValue()
              else
                  me.throwError "compiler set: only literal values allowed"
              
              me.getRootNode().parent.compilerVars.addMember item.name,{value:aValue}
            

### compiler if conditional compilation

        else if me.kind is 'if'

          me.conditional = me.req('IDENTIFIER')
          me.body = me.req(Body)


### other compile options

        else if me.kind is 'debugger' #debug-pause the compiler itself, to debug compiling process
          debugger

        else
          me.lexer.sayErr 'invalid compiler command'

        me.endLineInx = me.lexer.lineInx #(prettier generated code) remember end line to out as comments in the generated code


DefaultAssignment
-----------------

`DefaultAssignment: default AssignmentStatement`

It is a common pattern in javascript to use a object parameters (named "options")
to pass misc options to functions.

Litescript provide a 'default' construct as syntax sugar for this common pattern

The 'default' construct is formed as an ObjectLiteral assignment, 
but only the 'undfined' properties of the object will be assigned.

/*

    function theApi(object,options,callback)

      default options =
        log: console.log
        encoding: 'utf-8'
        throwErrors: true
        debug:
          enabled: false
          level: 2
      end default

      ...function body...

    end function
*/
is equivalent to js's:
/*

    function theApi(object,options,callback) {

        //defaults
        if (!options) options = {};
        if (options.log===undefined) options.log = console.log;
        if (options.encoding===undefined) options.encoding = 'utf-8';
        if (options.throwErrors===undefined) options.throwErrors=true;
        if (!options.debug) options.debug = {};
        if (options.debug.enabled===undefined) options.debug.enabled=false;
        if (options.debug.level===undefined) options.debug.level=2;

        ...function body...
    }
*/

    class DefaultAssignment inherits from ASTBase
/!
  
      properties
        assignment
!/

      method parse()

        me.reqValue 'default'
        me.lock()

        me.assignment = me.req(AssignmentStatement)


End Statement
-------------

`EndStatement: end (IDENTIFIER)* NEWLINE`

`end` is an **optional** end-block marker to ease code reading.
It marks the end of code blocks, and can include extra tokens referencing the construction
closed. (in the future) This references will be cross-checked, to help redude subtle bugs
by checking that the block ending here is the intended one.

If it's not used, the indentation determines where blocks end ()

Example: `end if` , `end loop`, `end for each item`

Usage Examples:  
/*

    if a is 3 and b is 5
      print "a is 3"
      print "b is 5"
    end if

    loop while a < 10
      a++
      b++
    end loop
*/

    class EndStatement inherits from ASTBase
/!
  
      properties
        references:string array
!/

      method parse()

        me.reqValue 'end'

        me.lock()
        me.references=[]
 
The words after `end` are just 'loose references' to the block intended to be closed
We pick all the references up to EOL (or EOF)

        while not me.opt('NEWLINE','EOF')

Get optional identifier reference
We save `end` references, to match on block indentation,
for Example: `end for` indentation must match a `for` statement on the same indent


            var ref = me.opt('IDENTIFIER')
            if ref
                me.references.push(ref)

        #end loop


WaitForAsyncCall
----------------

`WaitForAsyncCall: wait for FunctionCall`

The `wait for` expression calls a normalized async function 
and `waits` for the async function to execute the callback.

A normalized async function is an async function with the last parameter = callback(err,data)

The waiting is implemented by exisiting libs.

Example: `contents = wait for fs.readFile('myFile.txt','utf8')`

    class WaitForAsyncCall inherits from ASTBase
/!
  
      properties
        call
!/

      method parse()

        me.reqValue 'wait'
        me.lock()

        me.reqValue 'for'
        me.call = me.req(FunctionCall)


LaunchStatement
---------------

`LaunchStatement: 'launch' FunctionCall`

`launch` starts a generator function.
The generator function rus as a co-routine, (pseudo-parallel), 
and will be paused on `wait for` statements.

The `launch` statement will return on the first `wait for` or `yield` of the generator

    class LaunchStatement inherits from ASTBase
/!
  
      properties
        call
!/

      method parse()

        me.reqValue 'launch'
        me.lock()

        me.call = me.reqValue(FunctionCall)


Adjective
---------

`Adjective: (public|generator|shim|helper)`

    class Adjective inherits from ASTBase

      method parse()

        me.name = me.reqValue("public","generator","shim","helper")


###a Helper method, Check validity of adjective-statement combination 
      
      method validate(statement)

        var validCombinations = { public: ['class','function','var'] ,
                                  generator: ['function','method'] ,
                                  shim: ['function','method','class'] ,
                                  helper:  ['function','method','class'] }

/!

        declare valid:array
        declare valid statement.keyword
!/

        var valid = validCombinations[me.name] or ['-*none*-']
        if not (statement.keyword in valid)
            me.throwError "'#{me.name}' can only apply to #{valid.join('|')} not to '#{statement.keyword}'"
        
Also convert adjectives to Statement node properties to ease code generation

        statement[me.name] = true




Statement
---------

A `Statement` is an imperative statment (command) or a control construct.

The `Statement` node is a generic container for all previously defined statements. 

The generic `Statement` is used to define `Body: (Statement;)`, that is,
**Body** is a list of semicolon (or NEWLINE) separated **Statements**.

`Statement: [Adjective]* (ClassDeclaration|FunctionDeclaration
|IfStatement|ForStatement|WhileUntilLoop|DoLoop
|AssignmentStatement|FunctionCall
|LoopControlStatement|ThrowStatement
|TryCatch|ExceptionBlock
|ReturnStatement|PrintStatement) | DoNothingStatement | VariableRef (AssignmentStatement,FunctionCall)`

    class Statement inherits from ASTBase
/!
  
      properties
        adjectives: Adjective array
        statement
        preParsedVarRef

!/

      method parse()

        #debug show line and tokens
        debug ""
        me.lexer.infoLine.dump()

#support old SYNTAX - REMOVE LATER

        var pos=me.lexer.getPos()
        if me.optValue('method')
          if me.optValue('initialize')
            me.lexer.returnToken()
            me.lexer.token.value ='constructor'
          else
            me.lexer.setPos pos

#END support old SYNTAX - 


First,fast-parse the statement by using a table.
We look up the token (keyword) in **StatementsDirect** table, and parse the specific AST node

        me.statement = me.parseDirect(me.lexer.token.value, StatementsDirect)
        if no me.statement

If it was not found, try optional adjectives (zero or more). Adjectives precede statement keyword.
Recognized adjectives are: `(public|generator|shim|helper)`. 

          me.adjectives = me.optList(Adjective)

Now re-try fast-parse

          me.statement = me.parseDirect(me.lexer.token.value, StatementsDirect)
          if no me.statement

If the token wasn't on StatementsDirect, or parse failed, lets try DoNothingStatement 
(It is not in StatementsDirect because starts wih 'do' as DoLoopStatement)

            me.statement = me.opt(DoNothingStatement)
            if no me.statement

Last possibilities are: AssignmentStatement or FunctionCall
both starts with a VariableRef:

First **require** the VariableRef (performance)

              me.preParsedVarRef = me.req(VariableRef)

Then **require** one of AssignmentStatement or FunctionCall (this is the last option)
Note: both will use the pre-parsed VariableRef

              me.statement = me.req(AssignmentStatement,FunctionCall)

        #end if - statement parse tries

If we reached here, we have parsed a valid statement 
Check validity of adjective-statement combination 
        
        if me.adjectives
          for adj in me.adjectives
            adj.validate(me.statement)



###a helper method to check adjectives asosciated to this statement

      method isAdjectivated(adjName)

        if me.adjectives
          for adj in me.adjectives
            if adj.name is adjName 
              return true



## Body

`Body: (Statement;)`

Body is a semicolon-separated list of statements (At least one)

`Body` is used for "Module" body, "class" body, "function" body, etc.
Anywhere a list of semicolon separated statements apply.

    class Body inherits from ASTBase
/!

      properties
        statements: Statement array
!/

      method parse()

start from parent indent to recognize "indented" body lines

        me.indent = me.parent.indent

We use the generic ***ASTBase.reqSeparatedList*** to get a list of **Statement** symbols, 
*semicolon* separated or in freeForm mode: one statement per line, closed when indent changes.

        me.statements = me.reqSeparatedList(Statement,";")


Single Line Statement
--------------------

This construction is used when a statement is expected on the same line.
It is used by `IfStatement: if conditon-Expression (','|then) *SingleLineStatement*`
It is also used for the increment statemenf in for-while loops:`for x=0; while x<10 [,SingleLineStatement]`

    class SingleLineStatement inherits from Body

      method parse()

        if me.lexer.token.type is 'NEWLINE'
          me.lexer.returnToken()
          me.lock()
          me.lexer.sayErr "Expected statement on the same line after '#{me.lexer.token.toString()}'"

        # normally: ReturnStatement, ThrowStatement, PrintStatement, AssignmentStatement, FunctionCall
        # but we parse any Statement

        Body.prototype.parse.apply(this,arguments)


## Module

The `Module` represents a complete source file. 

    class Module inherits from ASTBase

      method parse()

We start by locking. There is no other construction to try,
if Module.parse() fails we abort compilation.

          me.lock()

Get Module body: Statements, separated by NEWLINE|';' closer:'EOF'

          me.statements = me.optFreeFormList(Statement,';','EOF')

      #end Module parse


----------------------------------------

Table-based (fast) Statement parsing
------------------------------------

This a extension to PEGs.
To make the compiler faster and easier to debug, we define an 
object with name-value pairs: `"keyword" : AST node class` 

We look here for fast-statement parsing, selecting the right AST node to call `parse()` on 
based on `token.value`. (instead of parsing by ordered trial & error)

This table makes a direct parsing of almost all statements, thanks to a core definition of LiteScript:
Anything standing aline in it's own line, its an imperative statement (it does something, it produces effects).

    var StatementsDirect = {'var': VarStatement,
      'let': VarStatement,
      'function': FunctionDeclaration,
      'class': ClassDeclaration,
      'append': AppendToDeclaration,
      'constructor': ConstructorDeclaration,
      'properties': PropertiesDeclaration,
      'namespace': PropertiesDeclaration,
      'method': MethodDeclaration,
      'default': DefaultAssignment,
      'if': IfStatement,
      'when': IfStatement,
      'for':ForStatement,
      'while':WhileUntilLoop,
      'until':WhileUntilLoop,
      'do':DoLoop,
      'break':LoopControlStatement,
      'continue':LoopControlStatement,
      'end':EndStatement,
      'return':ReturnStatement,
      'print':PrintStatement,
      'throw':ThrowStatement,
      'raise':ThrowStatement,
      'fail':ThrowStatement,
      'try':TryCatch,
      'exception':ExceptionBlock,
      'debugger':DebuggerStatement, 
      'declare':DeclareStatement,
      'compile':CompilerStatement,
      'compiler':CompilerStatement,
      'wait':WaitForAsyncCall, 
      'launch':LaunchStatement
    }

    AccessorsDirect = {'.': PropertyAccess,
      '[': IndexAccess,
      '(': FunctionAccess }


------------
Exports

A list of Grammar classes to export.

    var Nodes = [ASTBase,
                Module, Statement, Body, SingleLineStatement,
                NameDeclaration, VariableRef, 
                Accessors, PropertyAccess,IndexAccess,FunctionAccess,
                AssignmentStatement, VarStatement, VariableDecl,
                Oper, UnaryOper, Operand, Expression,ParenExpression,
                Literal, NumberLiteral, StringLiteral, RegExpLiteral, 
                ArrayLiteral, ObjectLiteral, FreeObjectLiteral, NameValuePair, 
                IfStatement, ElseIfStatement, ElseStatement, 
                ForStatement, ForEachProperty,ForIndexNumeric,ForEachInArray,
                WhileUntilLoop, DoLoop, WhileUntilExpression, LoopControlStatement, 
                FunctionDeclaration, FunctionCall, 
                PrintStatement, EndStatement, DefaultAssignment,
                AppendToDeclaration, PropertiesDeclaration,
                ClassDeclaration, ConstructorDeclaration,  MethodDeclaration,
                ThrowStatement, ReturnStatement, 
                TryCatch, ExceptionBlock,
                DoNothingStatement, DeclareStatement,
                CompilerStatement,
                WaitForAsyncCall ]

/!
      
    declare v:ASTBase
!/

    for v in Nodes
      exports[v.name] = v

    exports.ASTBase = ASTBase

    exports.NameDeclaration = NameDeclaration
    exports.VariableDecl = VariableDecl
    exports.Expression = Expression
    exports.VariableRef = VariableRef

    exports.PropertyAccess = PropertyAccess
    exports.FunctionAccess = FunctionAccess
    exports.IndexAccess = IndexAccess

    exports.Module = Module

    exports.Literal = Literal
    exports.StringLiteral = StringLiteral
    exports.ObjectLiteral = ObjectLiteral
    exports.FreeObjectLiteral = FreeObjectLiteral
    exports.Body = Body
    exports.Statement = Statement
    exports.ThrowStatement = ThrowStatement
    exports.ClassDeclaration = ClassDeclaration
    exports.VarStatement = VarStatement
    exports.CompilerStatement = CompilerStatement
    exports.DeclareStatement = DeclareStatement
    exports.AssignmentStatement = AssignmentStatement
    exports.SingleLineStatement = SingleLineStatement
    exports.ReturnStatement = ReturnStatement
    exports.FunctionCall = FunctionCall
    exports.Operand=Operand    
    exports.UnaryOper=UnaryOper
    exports.Oper=Oper
    exports.DefaultAssignment=DefaultAssignment
    exports.Accessors = Accessors
    exports.IfStatement=IfStatement
    exports.ElseIfStatement=ElseIfStatement
    exports.ElseStatement=ElseStatement
    exports.ForStatement=ForStatement
    exports.ForEachProperty = ForEachProperty
    exports.ForIndexNumeric = ForIndexNumeric
    exports.ForEachInArray = ForEachInArray
    exports.WhileUntilExpression=WhileUntilExpression
    exports.DoLoop=DoLoop
    exports.DoNothingStatement=DoNothingStatement
    exports.LoopControlStatement=LoopControlStatement
    exports.ParenExpression=ParenExpression
    exports.ArrayLiteral=ArrayLiteral
    exports.NameValuePair=NameValuePair
    exports.FunctionDeclaration=FunctionDeclaration
    exports.PrintStatement=PrintStatement
    exports.EndStatement=EndStatement
    exports.ConstructorDeclaration =ConstructorDeclaration 
    exports.AppendToDeclaration=AppendToDeclaration
    exports.TryCatch=TryCatch
    exports.ExceptionBlock=ExceptionBlock
    exports.WaitForAsyncCall=WaitForAsyncCall
    exports.PropertiesDeclaration = PropertiesDeclaration
