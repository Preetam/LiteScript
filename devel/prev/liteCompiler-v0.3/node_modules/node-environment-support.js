
//-------------------------------------------------------
// Environment support to run LiteScritp compiler on node
//-------------------------------------------------------

//Dependencies

   var path = require('path');
   var fs = require('fs');

   var mkPath = require('mkPath');

   var log = require('log');
   var debug = log.debug;


//module vars

//    declare valid process.cwd
   var basePath = process.cwd();

//------------------------------

   // Class FileInfo, constructor:
   function FileInfo(importParameter){

       this.importParameter = importParameter;
       this.filename = importParameter;
       this.dirname = path.dirname(importParameter);
       this.hasPath = [path.delimiter, '.'].indexOf(importParameter[0])>=0;
       this.extension = path.extname(importParameter);
       this.basename = path.basename(importParameter, this.extension);

//        #remove .lite from double extension .lite.md
       this.basename = this.basename.replace(/.lite$/, "");

        //relative to basePath
       this.relPath = path.relative(basePath, this.dirname);
       this.relFilename = path.relative(basePath, this.filename);
    };
   
   // declared properties & methods
//     properties
//        importParameter:string #: raw string passed to import/require
//        dirname:string #: path.dirname(importParameter)
//        extension:string #: path.extname(importParameter)
//        basename:string #: path.basname(importParameter)
//        hasPath # true if starts with '.' or '/'
//        isCore # true if it's a core node module as 'fs' or 'path'
//        isLite #: true is extension is '.lite'|'.lite.md'
//        filename:string #: found full module filename
//        relPath:string # path.relative(basePath, this.dirname); //relative to basePath
//        relFilename
//        outPath # output path
//        outFilename #: output file for code production
//        outRelFilename # path.relative(basePath, this.outFilename); //relative to basePath
//        outExtension
//        interfaceFile #: interface file (.[auto-]interface.md) declaring exports cache
//        interfaceFileExists #: if interfaceFileName file exists
//        externalCacheExists

    //method searchModule(importingModuleFileInfo, options )
    FileInfo.prototype.searchModule = function(importingModuleFileInfo, options){

//------------------
//provide a searchModule function to the LiteScript environment
// to use to locate modules for the `import/require` statement
//------------------

       //default options =
       if(!options) options={};
       if(options.outDir===undefined) options.outDir='out/debug';
       if(options.target===undefined) options.target='js';

//check if it's a core module like 'fs' or 'path'

       //if no this.hasPath and no this.extension and isBuiltInModule(this.basename)
       if (!this.hasPath && !this.extension && isBuiltInModule(this.basename)) {
           this.isCore = true;
           this.isLite = false;
           //return
           return;
       };

//if parameter has no extension or extension is [.lite].md
//we search the module

       //if no this.extension or this.extension is '.md'
       if (!this.extension || this.extension === '.md') {

            //search the file
           var search = undefined;
           //if this.hasPath #specific path indicated
           if (this.hasPath) {// #specific path indicated
               search = path.resolve(importingModuleFileInfo.dirname, this.importParameter);
           }
           else {
                //search in node_modules, unless we're already in node_modules:
               //if path.basename(importingModuleFileInfo.dirname) is 'node_modules'
               if (path.basename(importingModuleFileInfo.dirname) === 'node_modules') {
                   search = path.join(importingModuleFileInfo.dirname, this.importParameter);
               }
               else {
                   search = path.join(importingModuleFileInfo.dirname, 'node_modules', this.importParameter);
               };
           };

           var full = undefined, found = undefined;
           //for each ext in ['.lite.md','.lite','.js']
           for ( var ext__inx=0,ext=undefined; ext__inx<['.lite.md', '.lite', '.js'].length; ext__inx++) {
               var ext=['.lite.md', '.lite', '.js'][ext__inx];
               full = search + ext;
               //if fs.existsSync(full)
               if (fs.existsSync(full)) {
                   found = full;
                   //break;
                   break;
               };
           }; // end for each in ['.lite.md', '.lite', '.js']

            //console.log(basePath);
            //console.log(full);

           //if not found, log.throwControled '#importingModuleFileInfo.filename: Module not found: #this.importParameter\nSearched as:\n #search(.lite.md|.lite|.js)]'
           if (!(found)) {
               log.throwControled(importingModuleFileInfo.filename + ': Module not found: ' + this.importParameter + '\nSearched as:\n ' + search + '(.lite.md|.lite|.js)]')};

            //set filename & Recalc extension
           this.filename = full; //full path
           this.extension = path.extname(this.filename);
           this.basename = path.basename(this.filename, this.extension).replace(/.lite$/, "");// #remove .lite from double extension .lite.md
       }
       else {

            //other extensions
            //No compilation (only copy to output dir), and keep extension
           this.filename = path.resolve(importingModuleFileInfo.dirname, this.importParameter);
       };


        //recalc data from found file
       this.dirname = path.dirname(this.filename);
       this.relPath = path.relative(basePath, this.dirname); //relative to basePath
       this.relFilename = path.relative(basePath, this.filename); //relative to basePath

       this.outPath = path.resolve(basePath, options.outDir, this.relPath);

        // based on result extension
       this.isLite = ['.md', '.lite'].indexOf(this.extension)>=0;
       this.outExtension = this.isLite ? "." + options.target : (this.extension || '.js');

       this.outFilename = path.join(this.outPath, this.basename + this.outExtension);
       this.outRelFilename = path.relative(basePath, this.outFilename); //relative to basePath

//Also calculate this.interfaceFile (cache of module exported names),
//check if the file exists, and if it is updated

       this.interfaceFile = path.join(this.dirname, this.basename + '.interface.md');
       var isCacheFile = undefined;
       //if fs.existsSync(this.interfaceFile)
       if (fs.existsSync(this.interfaceFile)) {
           this.interfaceFileExists = true;
           isCacheFile = false;
       }
       else {
            //set for auto-generated interface
           this.interfaceFile = path.join(this.dirname, this.basename + '.cache-interface.md');
           isCacheFile = true;
           this.interfaceFileExists = fs.existsSync(this.interfaceFile);
       };

//Check if interface cache is updated

       //if this.interfaceFileExists and isCacheFile
       if (this.interfaceFileExists && isCacheFile) {
            //get source date & time
           var stat = fs.statSync(this.filename);
//            declare on stat mtime
            //get interface date & time
           var statInterface = fs.statSync(this.interfaceFile);
//            declare on statInterface mtime
            //cache exists if source is older
           this.interfaceFileExists = (statInterface.mtime > stat.mtime);
           //if not this.interfaceFileExists, externalCacheSave this.interfaceFile,null //delete cache file if outdated
           if (!(this.interfaceFileExists)) {
               externalCacheSave(this.interfaceFile, null)};
       };

       //debug this
       debug(this);

       //return
       return;
    };
   exports.FileInfo = FileInfo;
   //end class FileInfo

   //end class FileInfo
//----------

   //public function setBasePath(newBasePath)
   function setBasePath(newBasePath){
       basePath = newBasePath;
   };
   exports.setBasePath=setBasePath;

   //public function relName(filename)
   function relName(filename){
        //relative to basePath
       //return path.relative(basePath, filename)
       return path.relative(basePath, filename);
   };
   exports.relName=relName;

//----------

   //public function loadFile(filename)
   function loadFile(filename){
    //------------------
    //provide a loadFile function to the LiteScript environment.
    //return file contents
    //------------------
       //return fs.readFileSync(filename);
       return fs.readFileSync(filename);
   };
   exports.loadFile=loadFile;


   //public function externalCacheSave(filename, fileLines)
   function externalCacheSave(filename, fileLines){
    //------------------
    //provide a externalCacheSave (disk) function to the LiteScript environment
    // receive a filename and an array of lines
    //------------------
       //if no fileLines
       if (!fileLines) {
           //if fs.existsSync(filename)
           if (fs.existsSync(filename)) {
                //remove file
               //fs.unlinkSync filename
               fs.unlinkSync(filename);
           };
       }
       else {

           //if fileLines instanceof Array
           if (fileLines instanceof Array) {
//                declare fileLines:Array
               fileLines = fileLines.join("\n");
           };

            //console.log('save file',filename,fileLines.length,'lines');

           //mkPath.toFile filename // make sure output dir exists
           mkPath.toFile(filename); // make sure output dir exists
           //fs.writeFileSync filename,fileLines
           fs.writeFileSync(filename, fileLines);
       };
   };
   exports.externalCacheSave=externalCacheSave;


    //------------------
    // Check for built in and global names
    //------------------

   //public function isBuiltInModule (name,prop)
   function isBuiltInModule(name, prop){
    //
    // return true if 'name' is a built-in node module
    //

      var isCoreModule = ['assert', 'buffer', 'child_process', 'cluster', 'crypto', 'dgram', 'dns', 'events', 'fs', 'http', 'https', 'net', 'os', 'path', 'punycode', 'querystring', 'readline', 'repl', 'string_decoder', 'tls', 'tty', 'url', 'util', 'vm', 'zlib'].indexOf(name)>=0;

      //if isCoreModule
      if (isCoreModule) {
           //if no prop, return true; //just asking: is core module?
           if (!prop) {
               return true};

           var r = require(name); //load module
           //if r has property prop, return true; //is the member there?
           if (prop in r) {
               return true};
      };
   };
   exports.isBuiltInModule=isBuiltInModule;


   //public function isBuiltInObject(name)
   function isBuiltInObject(name){
    //
    // return true if 'name' is a javascript built-in object
    //

       //return name in ['isNaN','parseFloat','parseInt','isFinite'
       return ['isNaN', 'parseFloat', 'parseInt', 'isFinite', 'decodeURI', 'decodeURIComponent', 'encodeURI', 'encodeURIComponent', 'eval', 'console', 'process', 'require'].indexOf(name)>=0;
   };
   exports.isBuiltInObject=isBuiltInObject;



   //public function getGlobalObject(name)
   function getGlobalObject(name){
       //try
       try{
           //return global[name]
           return global[name];
       
       }catch(e){
           //log.error "Environment.getGlobalObject '#name'"
           log.error("Environment.getGlobalObject '" + name + "'");
           //log.error e.stack
           log.error(e.stack);
           //debugger
           debugger;
       };
   };
   exports.getGlobalObject=getGlobalObject;
