//-------------------------------------------------------
// Environment support to run LiteScritp compiler on node
//-------------------------------------------------------

//Dependencies

    var path = require('path');
    var fs   = require('fs');

    var mkPath = require('mkPath'); 

    var log = require('log')
    var debug = log.debug


module vars

    declare valid process.cwd
    var basePath = process.cwd()

//------------------------------

### Public Class FileInfo
     properties
        importParameter:string #: raw string passed to import/require
        dirname:string #: path.dirname(importParameter)
        extension:string #: path.extname(importParameter)
        basename:string #: path.basname(importParameter)
        hasPath # true if starts with '.' or '/'
        isCore # true if it's a core node module as 'fs' or 'path'
        isLite #: true is extension is '.lite'|'.lite.md' 
        filename:string #: found full module filename
        relPath:string # path.relative(basePath, this.dirname); //relative to basePath
        relFilename
        outPath # output path 
        outFilename #: output file for code production
        outRelFilename # path.relative(basePath, this.outFilename); //relative to basePath
        outExtension
        interfaceFile #: interface file (.[auto-]interface.md) declaring exports cache
        interfaceFileExists #: if interfaceFileName file exists
        externalCacheExists


#### constructor (importParameter)
          
        this.importParameter = importParameter
        this.filename = importParameter
        this.dirname = path.dirname(importParameter)
        this.hasPath = importParameter[0] in [path.delimiter,'.']
        this.extension = path.extname(importParameter)
        this.basename = path.basename(importParameter,this.extension)

        #remove .lite from double extension .lite.md
        this.basename = this.basename.replace(/.lite$/,"")

        //relative to basePath
        this.relPath = path.relative(basePath, this.dirname) 
        this.relFilename = path.relative(basePath, this.filename) 

#### method searchModule(importingModuleFileInfo, options )

//------------------
//provide a searchModule function to the LiteScript environment
// to use to locate modules for the `import/require` statement
//------------------

        default options = 
            outDir: 'out/debug'
            target: 'js'
        
check if it's a core module like 'fs' or 'path'

        if no this.hasPath and no this.extension and isBuiltInModule(this.basename)
            this.isCore = true
            this.isLite = false
            return 

if parameter has no extension or extension is [.lite].md
we search the module 

        if no this.extension or this.extension is '.md'

            //search the file
            var search;
            if this.hasPath #specific path indicated
                search = path.resolve(importingModuleFileInfo.dirname,this.importParameter)
            else
                //search in node_modules, unless we're already in node_modules:
                if path.basename(importingModuleFileInfo.dirname) is 'node_modules'
                    search = path.join(importingModuleFileInfo.dirname, this.importParameter)
                else
                    search = path.join(importingModuleFileInfo.dirname,'node_modules',this.importParameter)

            var full,found;
            for each ext in ['.lite.md','.lite','.js']
                full = search+ext;
                if fs.existsSync(full)
                    found=full;
                    break;
                
            //console.log(basePath);
            //console.log(full);

            if not found, log.throwControled '#importingModuleFileInfo.filename: Module not found: #this.importParameter\nSearched as:\n #search(.lite.md|.lite|.js)]'
            
            //set filename & Recalc extension
            this.filename = full; //full path
            this.extension = path.extname(this.filename);
            this.basename = path.basename(this.filename,this.extension).replace(/.lite$/,"") #remove .lite from double extension .lite.md
        
        else 

            //other extensions
            //No compilation (only copy to output dir), and keep extension 
            this.filename = path.resolve(importingModuleFileInfo.dirname,this.importParameter);
        

        //recalc data from found file
        this.dirname = path.dirname(this.filename);
        this.relPath = path.relative(basePath, this.dirname); //relative to basePath
        this.relFilename = path.relative(basePath, this.filename); //relative to basePath

        this.outPath = path.resolve(basePath, options.outDir, this.relPath)

        // based on result extension                
        this.isLite = this.extension in ['.md','.lite']
        this.outExtension = this.isLite? ".#options.target": (this.extension or '.js');
            
        this.outFilename = path.join(this.outPath,this.basename+this.outExtension);
        this.outRelFilename = path.relative(basePath, this.outFilename); //relative to basePath

Also calculate this.interfaceFile (cache of module exported names), 
check if the file exists, and if it is updated

        this.interfaceFile = path.join(this.dirname,this.basename+'.interface.md');
        var isCacheFile
        if fs.existsSync(this.interfaceFile)
            this.interfaceFileExists = true
            isCacheFile = false
        else
            //set for auto-generated interface
            this.interfaceFile = path.join(this.dirname,this.basename+'.cache-interface.md');
            isCacheFile = true
            this.interfaceFileExists = fs.existsSync(this.interfaceFile)

Check if interface cache is updated

        if this.interfaceFileExists and isCacheFile
            //get source date & time 
            var stat = fs.statSync(this.filename);
            declare on stat mtime
            //get interface date & time 
            var statInterface = fs.statSync(this.interfaceFile);
            declare on statInterface mtime
            //cache exists if source is older
            this.interfaceFileExists = (statInterface.mtime > stat.mtime ); 
            if not this.interfaceFileExists, externalCacheSave this.interfaceFile,null //delete cache file if outdated

        debug this
        
        return
    
    end class FileInfo
----------

    public function setBasePath(newBasePath)
        basePath = newBasePath

    public function relName(filename)
        //relative to basePath
        return path.relative(basePath, filename)
    
----------

    public function loadFile(filename)
    //------------------
    //provide a loadFile function to the LiteScript environment.
    //return file contents
    //------------------
        return fs.readFileSync(filename);
    

    public function externalCacheSave(filename, fileLines)
    //------------------
    //provide a externalCacheSave (disk) function to the LiteScript environment
    // receive a filename and an array of lines
    //------------------
        if no fileLines
            if fs.existsSync(filename)
                //remove file
                fs.unlinkSync filename

        else 

            if fileLines instanceof Array 
                declare fileLines:Array
                fileLines=fileLines.join("\n")

            //console.log('save file',filename,fileLines.length,'lines');

            mkPath.toFile filename // make sure output dir exists
            fs.writeFileSync filename,fileLines


    //------------------
    // Check for built in and global names
    //------------------
    
    public function isBuiltInModule (name,prop)
    //
    // return true if 'name' is a built-in node module
    //

       var isCoreModule = name in ['assert', 'buffer', 'child_process', 'cluster',
          'crypto', 'dgram', 'dns', 'events', 'fs', 'http', 'https', 'net',
          'os', 'path', 'punycode', 'querystring', 'readline', 'repl',
          'string_decoder', 'tls', 'tty', 'url', 'util', 'vm', 'zlib']

       if isCoreModule
            if no prop, return true; //just asking: is core module?

            var r = require(name); //load module
            if r has property prop, return true; //is the member there?
            
     
    public function isBuiltInObject(name)
    //
    // return true if 'name' is a javascript built-in object
    //

        return name in ['isNaN','parseFloat','parseInt','isFinite'
            ,'decodeURI','decodeURIComponent'
            ,'encodeURI','encodeURIComponent'
            ,'eval','console'
            ,'process','require']

    

    public function getGlobalObject(name)
        try 
            return global[name]
        
        catch e
            log.error "Environment.getGlobalObject '#name'"
            log.error e.stack
            debugger



